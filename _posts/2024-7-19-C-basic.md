---
layout: post

title: C基本知识
categories: [C]
tags: [C,八股]
typora-root-url: ..
---

## c语言

### 变量

#### 命名

1. **字符集**：

   - 变量名只能包含字母（大写 A-Z 和小写 a-z）、数字（0-9）和下划线（_）。
   - 变量名不能以数字开头。

2. **大小写敏感**：

   - C 语言区分大小写。因此，`variable` 和 `Variable` 被认为是两个不同的变量。

3. **关键字限制**：

   - 变量名不能是 C 语言的关键字。例如，不能使用 `int`、`return`、`for` 等作为变量名。

4. **长度限制：**

   现代编译器通常允许超过255个字符，但是一般使用时（做题时）是最多31个字符

#### 初始化

**局部变量（Local Variables）**

- **未初始化的局部变量**：局部变量在声明时如果未被显式初始化，其初始值是未定义的。具体来说，局部变量会占用栈内存区域，栈内存中的数据不会被自动初始化，因此这些变量可能会包含随机值，通常是之前程序运行中栈上残留的数据。

**全局变量（Global Variables）**

- **未初始化的全局变量**：全局变量在未被显式初始化时，默认初始值为 0。全局变量存储在 BSS 段（Block Started by Symbol），该段会在程序加载时被操作系统初始化为 0。

**静态变量（Static Variables）**

- **未初始化的静态变量**：无论是局部静态变量还是全局静态变量，如果未被显式初始化，其默认初始值都是 0。静态变量存储在数据段（Data Segment），该段在程序加载时也会被操作系统初始化为 0。

### typedef

```
typedef 可以用来定义各种类型的别名，包括但不限于：

基本数据类型的别名：如 int、float、char 等。
复合数据类型的别名：如结构体、联合体、枚举等。
指针类型的别名：如 int*、char* 等。
函数类型的别名：如函数指针类型。
用户自定义类型的别名：自定义的结构体、枚举等类型。
```

```
typedef int Integer;
typedef float Float;
typedef char Character;

```



### 结构体

```
// 使用 typedef 为结构体类型定义别名
typedef struct {
    char name[50];
    int age;
} Person;

// 使用别名声明变量
Person person1;
Person person2;

```

结构体可以直接进行复制。数组不能直接复制，但是数组被结构体包含时，可以直接复制。

```
https://blog.csdn.net/hazir/article/details/9429017
```

### 数组

初始化



### 关键字

#### const

const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置**类型变量**，**返回值**，**函数参数**。

```
1.修饰局部变量，全局变量。都不可以直接修改。但是，如下

const int b=10;
int main(int, char**){
    const int a=10;
    int *x=&a;
    int *y=&b;
    *x=11;
    *y=22;
}
address access protected (fault address: 0x402004)

所以局部变量使用const修饰会放在栈上，而全局变量const修饰放在了.bss段

c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放。而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放。

在c语言中可以通过指针对const局部变量进行修改，而不可以对const全局变量进行修改。因为const全局变量是存储在只读数据段
```

```
2.修饰形参，如果形参被const修饰，则参数是只读的。在函数原型和函数头，形参声明 canst int array [] 与 canst int * array 相同 ， 所以该声明不能更改 array 指向的数据。
```

```
3.修饰函数的返回值
如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。

例如函数
const char* GetString(void);

如下语句将出现编译错误：
char*str = GetString();

正确的用法是
const char*str = GetString();
```

```
4.关于指针
const int * p;
int * const p;

从右向左读，得到他的名称，例如一常量指针；

从左向右读，得到他的功能，例如一，p是一个指针 指向了cont，例如二，p是一个常量，常量是指针。
```



#### volatile

##### 1.介绍	

​	volatile限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。

​	通常，它被用硬件地址以及在其他程序或同时运行的线程中共享数据。例如,一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。

​	语法同const一样。

```c
vall=x;／＊一些不使用x的代码＊／
/*外部改变x的值*/
val2=x;
```

​	如果不声明volatile，那么编译器会优化x，从寄存器中读取，而不是从内存中读取。

​	现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。

##### 2.一般用处：

　　**一般说来，volatile用在如下的几个地方：** 
　　**1） 中断服务程序中修改的供其它程序检测的变量，需要加volatile；** 

　　当变量在触发某中断程序中修改，而编译器判断主函数里面没有修改该变量，因此可能只执行一次从内存到某寄存器的读操作，而后每次只会从该寄存器中读取变量副本，使得中断程序的操作被短路。
　　**2） 多任务环境下各任务间共享的标志，应该加volatile；** 

　　在本次线程内, 当读取一个变量时，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值；当内存变量或寄存器变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致 。
　　**3） 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；**

​	假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。for(i=0;i< 10;i++)  *output = i;前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，省略了对该硬件IO端口反复读的操作。

##### 3.几个问题

 　 **1)一个参数既可以是const还可以是volatile吗？**

　　可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

​		意思就是这个东西，只能外部程序改变，该程序不能改变。

　　**2) 一个指针可以是volatile 吗？**

　　可以，当一个中服务子程序修改一个指向buffer的指针时。

```
int a=10;
volatile int *p=&a;

*a!=10; 因为指针式volatile，可能被改变了。
```

`volatile`关键字的语法和`const`一样，可作用于所指对象或者指针存储地址

```
// 作用于对象
volatile char *vpch;
// 作用于指针地址
char * volatile pchv;
```

`volatile`关键字指定了可以通过用户应用程序中的操作以外的操作进行修改，对于在共享内存中声明可由多个进程或用于与中断服务例程通信的全局数据区域访问的对象非常有用

当对象声明为`volatile`时，每次程序访问编译器都将从存储器中获取对象值。这极大地减少了可能的优化。如果对象的状态无法预期时，这是确保可预测的程序性能的唯一途径





#### restrict

​	　restrict，C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。

**渊源：**

　　restrict是c99标准引入的，它只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式.即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,而不能通过其它途径(其它变量或指针)来修改;

这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.

如

```
 int *restrict ptr
```

ptr 指向的内存单元只能被 ptr访问到，任何同样指向这个内存单元的其他指针都是未定义的，直白点就是无效指针。restrict 的出现是因为 C 语言本身固有的缺陷，C 程序员应当主动地规避这个缺陷，而编译器也会很配合地优化你的代码.

　　**使用场景：**

- 非常需要性能。
- 需要改写指针的所指物。
- 明确知道某两个指针在业务逻辑上不会、也不能重叠

#### register

​	register 关键字暗示编译程序相应的变量将会被频繁的使用，如果**可能**的话，应将其保存在 CPU 的寄存器中，以加快其存取速度，例如下面的代码：

**1.1. Register限制**
	register 声明的变量必须是能被 CPU 所接受的类型。
	这通常意味着 register 变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。

​	因为 register 变量可能不存放在内存中，所以不能用 “&” 来获取 register 变量的地址。

​	只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。
在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量，而全局变量会一直占用寄存器

​	局部静态变量不能定义为寄存器变量，不能写成：register static int a, b, c;

​	由于寄存器的数量有限(不同的 CPU 寄存器数目不一)，不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据(如指针和浮点数)，因此真正起作用的 register 修饰符的数目和类型都依赖于运行程序的机器，而任何多余的 register 修饰符都将被编译程序所忽略。

**1.2. 合理使用Register**
	早期的 C 编译程序不会把变量保存在寄存器中，除非你命令它这样做，这时 register 修饰符是 C 语言的一种很有价值的补充。

​	然而，随着编译程序设计技术的进步，在决定哪些变量应该被存到寄存器中时，现在的 C 编译环境能比程序员做出更好的决定。

​	实际上，许多编译程序都会忽略 register 修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。



### 数组与指针



#### 指针和多维数组

p302





#### struct union typedef

strct声明结构体。没啥好说的。

```

```

union声明联合体。





两者典型应用

```c
typedefstructarch_spinlock{
	union{
		__ticketpair_thead_tail;
		struct__raw_tickets{
			__ticket_thead,tail;
		}tickets;
	};
}arch_spinlock_t;

typedefu32__ticketpair_t;
typedefu16__ticket_t;
```

所以上述两者的内存分布如下

```
｜-----------------------------------------------------
｜								u32head_tail													|
｜																											|
｜------------------------------------------------------
｜					head							|								tail			|
｜														|													|
｜-------------------------------------------------------
```

​	这样便可以方便的访问整体的某一部分。例如在嵌入式里面，某个寄存器的值是int型。其高16位代表某种含义，低16位代表某种含义。这样强制转化为这种结构体加联合体便可以方便访问。

```c
struct{
intx;
chary;
}a,b;
/*声明并定义ab结构体无法通过其他方式再次定义这种结构体*/
structp{
intc;
chard;
};
/*可以通过structp定义*/
typedefstruct{intk;charp;}name;
/*通过namex定义*/
typedefstructs{intk;charo;}low;
/*既可以通过structs定义又可以通过lowx定义*/
```

```
typedefaaaaxxxx
就是将aaaa定义为xxxx
```

![截屏2023-10-2820.42.15](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202310282042643.png)

#### c语言中内存管理，存储类别





对象：C语言把这样的一块内存称为对象(object)。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小

（面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言）。



标识符：标识符是一个名称，在这种情况下，标识符可以用来指定(designate)特定对象的内容。

​				标识符遵循变量的命名规则（第2章介绍过）。

存储期(storageduration)描述对象

可以用作用域(scope)和链接(linkage)描述标识符。标识符的作用域和链接表明了程序的哪些部分可以使用它



#### 作用域

作用域描述程序中可访问标识符的区域。作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。

#### 链接

C变量有3种链接属性：外部链接、内部链接或无链接。

具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。

这意味着这些变量属于定义它们的块、函数或原型私有。

具有文件作用域的变量可以是外部链接或内部链接。

外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。

#### 存储器

C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。

​	如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。注意，对于文件作用域变量，关键字static表明了其链接属性，而非存储期。以static声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。

#### 存储类别说明符

C语言有6个关键字作为存储类别说明符：auto、register、static、extern、_Thread_local和typedef。

​	auto说明符表明变量是自动存储期，只能用于块作用域的变量声明中。由于在块中声明的变量本身就具有自动存储期，所以使用auto主要是为了明确表达要使用与外部变量同名的局部变量的意图。

​	用static说明符创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。如果static用于文件作用域声明，作用域受限千该文件。如果static用千块作用域声明，作用域则受限于该块。因此，只要程序在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链接。

​	extern 说明符表明声明的变量定义在别处。 如果包含 extern 的声明具有文件作用域， 则引用的变量必须具有外部链接。 如果包含 extern 的声明具有块作用域， 则引用的变量可能具有外部链接或内部链接， 这接取决于该变量的定义式声明 。







#### 内联函数





### 运算符优先级

C语言中的运算符包括：

| 类别                 | 运算符                                                       | 说明                      |
| -------------------- | ------------------------------------------------------------ | ------------------------- |
| **算术运算符**       | `+`, `-`, `*`, `/`, `%`                                      | 都是双目运算符            |
| **关系运算符**       | `==`, `!=`, `>`, `<`, `>=`, `<=`                             | 都是双目运算符            |
| **逻辑运算符**       | `&&`, `||`, `!`                                              | ！单目运算符 其余都是双目 |
| **位运算符**         | `&`, `|`, `^`, `~`, `<<`, `>>`                               | ～ 单目 其余双目          |
| **赋值运算符**       | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=` | 双目                      |
| **增量和减量运算符** | `++`, `--`                                                   | 单目                      |
| **条件运算符**       | `? :`                                                        | 三目                      |
| 特殊运算符           | `[]`,`()`,`.`,`->`,`sizeof`,``                               |                           |

运算符优先级：

1.特殊运算符 `[]`,`()`,`.`,`->`最高 

2.所有单目运算符及sizeof `()`强制类型转换

3.双目运算符，算数运算（先乘，除，取模，后加，减）移位运算(`<<`,`>>`)，关系运算，位运算，逻辑运算

4.三目运算 

5.赋值运算

6.逗号

`?`是三元运算符

`++`,`--`是前缀或后缀运算符，没有结合性。

### 程序的内存布局

![image](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402161023396.png)

 顺便说说对象的存储，可分为三类：静态存储（static storage）；自动存储（automatic storage）；动态分配存储（allocated or dynamic storage）。

对于自动存储则对应的是栈（stack），动态分配存储对应的是堆（heap）；静态存储可分为.bss/.data/.rodata等数据段（section）。

```
.txt readonly shared 程序代码-->汇编代码
.rdata/.rodata segment 它是一段只读的segment 该segment存储静态的无名数据以及const修饰的常量，例如字符串常量，const修饰的全局变量（const修饰的局部变量放在栈上）。
.data 已经初始化的 全局变量，局部静态变量
.bss block start by symbol 未初始化的全局变量，局部静态变量


对于未初始化的全局变量和静态变量的初始值在运行期会被赋为0。从而，达到。bss section 用于减少目标文件的大小的目的。

临时变量（即局部非静态变量）既不出现在．data中，也不出现在。bss 中。它由运行期栈维护。

严格地讲，gcc 将 C程序（以.c结尾的源文件）中的未初始化的全局变量标记为 COMMON，而不是放到。bss section 中。对于 C++ 程序，无论是 gcc 还是 g++， 都会将程序中未初始化的全局变量放到 。bss section 中。关于这一点，有兴趣的可以自己验证下。
```

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402241805782.png)



# c语言



##### 4.下面的函数有什么错误：

```
int square(volatile int *ptr)
{
    return *ptr * *ptr;
}
```

该程序的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

[![复制代码](https://assets.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
int square(volatile int *ptr)
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}
```

[![复制代码](https://assets.cnblogs.com/images/copycode.gif)](javascript:void(0);)

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

```
long square(volatile int *ptr)
{
    int a;
    a = *ptr;
    return a * a;
}
```

 

注意：频繁地使用volatile很可能会增加代码尺寸和降低性能,因此要合理的使用volatile。



### 程序编译过程

### 宏定义与typedef







### 关键字

#####  **volatile关键字**

```
volatile的意思是”易变的”，这个关键字主要是防止编译器对变量进行优化即告诉编译器每次存取该变量的时候都要从内存去存取而不是使用它之前在寄存器中的备份。
详细分析一下什么是编译器优化，以及为什么使用这个关键字
```

```
volatile int a;


uchar * volatile reg
volatile uchar *reg;
此两者都是声明了一个 指针 指向uchar类型数据的指针。根据volatile位置不同，有不同的效果。


简单理解
第一种 volatile修饰reg表示reg是易变的 指向的值无所谓。用于共享指针

第二种 volatile修饰的是uchar * reg整体 表示值是易变的 reg指针无所谓。多用于驱动访问io端口。


复杂解释

第一种修饰的是reg变量说明reg指针变量是volatile的，但是指向的内容不是volatile的。
通常这种写法一般用在对共享指针的声明上，即这个指针变量有可能会被中断等函数修改。将其定义为volatile以后，编译器每次取指针变量的值的时候都会从内存中载入，这样即使这个变量已经被别的程序修改了，当前函数用的时候也能得到修改后的值（否则通常只在函数开始取一次放在寄存器里，以后就一直使用寄存器内的副本）。

这行代码里volatile修饰的是指针所指的内容。所以这里定义了一个uchar类型的指针，并且这个指针指向的是一个volatile的对象。但是指针变量本身并不是volatile的。如果对指针变量reg本身进行计算或者赋值等操作，是可能会被编译器优化的。但是对reg所指向的内容 reg的引用却禁止编译器优化。因为这个指针所指的是一个volatile的对象，所以编译器必须保证对reg的操作都不被优化。通常在驱动程序的开发中，对硬件寄存器指针的定义，都应该采用这种形式。
```



###### **（a）关于编译器优化**

首先理解CPU（寄存器）读取规则：

如下面程序段：

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402160942539.png)

如上图代码所示，a = 1这个程序，先将1写入CPU，再从CPU中将1写入a所在的内存地址中； b = a是先从内存中将a的值取出到CPU，再从CPU将值存入b的内存地址中。

如上图代码所示，上边的程序如果按第一段代码所说的顺序执行，则c = a语句在编译时是可以被编译器优化的，即注释部分（* 内存（&a） -> CPU *）的内容不被执行，因为在b = a这个语句中，a已经被移入过寄存器（CPU），那么在执行c = a时，就直接将a在寄存器（CPU）中传递给c这样就减少了一次指令的执行，就完成了优化

上面就是编译器优化的原理过程，但是这个过程，有时会出现问题，而这个问题也就volatile存在的意义！

###### **（b）volatile的引入**

上边程序中，如果在执行完b =a后，a此时的值存放在CPU中但是a在内存中又发生了变化（比如中断改变了a的值），但是存在CPU中的a是原来未变的a，按理应该是已经变化后的a赋值给c，但是此时却导致未变化的a赋值给了c

 这种问题，就是编译器自身优化而导致的为了防止编译器优化变量a，引入了volatile关键字，使用该关键字后，程序在执行时c = a时，就会先去a的地址读出a到CPU，再从CPU将a的值赋予给c这样就防止了被优化

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402160943461.png)

###### **（c）哪些情况下使用volatile**

​	根本上说，此变量的值有被外部改变的可能就用volatile。 

（1）并行设备的硬件寄存器存储器映射的硬件寄存器通常加volatile，因为寄存器随时可以被外设硬件修改。

​		当声明指向设备寄存器的指针时一定要用volatile，它会告诉编译器不要对存储在这个地址的数据进行假设

 （2）一个中断服务程序中修改的供其他程序检测的变量volatile提醒编译器，它后面所定义的变量随时都有可能改变因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象

 （3）多线程应用中被几个任务共享的变量

###### volatile 常见问题

1、一个参数可以是const还可以是volatile吗？

可以。比如只读的状态寄存器。它是volatile因为它可能被意想不到的改变，它是const因为 程序不应该试图去修改它。

2、一个指针可以是volatile吗？

可以。当一个服务中子程序修改一个指向buffer的指针时。

3、下面的函数段有问题吗？

```
int square(volatile int *ptr) 
{ 
    return *ptr * *ptr; 
} 
```

*ptr指向一个volatile型参数，*ptr的值随时可能被改变，所以代码段返回的可能不是所期望的平方值。

4、C语言编译过程中，volatile关键字和extern关键字分别在哪个阶段起作用
       volatile应该是在编译阶段，extern在链接阶段。
       volatile关键字的作用是防止变量被编译器优化，而优化是处于编译阶段，所以volatile关键字是在编译阶段起作用。



##### **static关键字**

###### 1.修饰局部变量

**其本质是：**

 普通的局部变量创建后是放在***\*栈区\****中，这种局部变量进入作用域时创建，出了作用域就销毁；

 但static修饰后的局部变量则放在**静态区**中，它改变了局部变量的存储位置，从而使得变量的生命周期延长，延长至程序结束才销毁。

###### static修饰局部变量只改变生命周期，不改变作用域！

[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)的变量都放在数据段，但是初始值若为0则放在BSS节中。而初始值非零则放在数据节中。也就是未被初始化的在bss中初始化为0。



###### 修饰全局变量

**其本质是：**

  全局变量本身是具有**外部链接属性**的，在A文件中定义的全局变量，在B文件中可以通过【**链接**】来使用；

  但如果全局变量被static修饰，那这个外部链接属性就会被修改成***\*内部链接属性\****，此时这个全局变量就只能在自己的源文件中使用；



###### **修饰函数**

>  static对函数的修饰与修饰全局变量十分相似，修饰函数时会改变函数的***\*链接属性\****，从而使得函数的作用域变小。



######  **面试问题1：static关键词的作用？**

 static是被声明为静态类型的变量，存储在静态区（全局区）中，其生命周期为整个程序，如果是静态局部变量，其作用域为一对{}内，如果是静态全局变量，其作用域为当前文件静态变量如果没有被初始化，则自动初始化为0

######  **面试问题2：为什么 static变量只初始化一次？**

 对于所有的对象（不仅仅是静态对象），初始化都只有一次，而由于静态变量具有“记忆”功能，初始化后，一直都没有被销毁，都会保存在内存区域中，所以不会再次初始化存放在静态区的变量的生命周期一般比较长，它与整个程序“同生死、共存亡”，所以它只需初始化一次而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁

######  **static修饰的全局变量，只能在本文件被调用；修饰的函数也只能在本文件调用**



##### **const关键字**

###### **定义变量**

```
const int a=0;
a=8; // error
const int p;//error


const int * a; 数据只读
int * const a; 指针只读

volatile uchar *reg; 数据易变
uchar * volatile reg 指针易变
```

1.const 作用在编译阶段
3.用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。
4.const定义的是变量，而define定义的是常量。

```
const修饰指针，以*为中心，const在*左边，则指针指向的数据只读，const在*右边，则指针本身只读，四个字：左数右指。
volatile 同理
const 同理
```

###### **c）修饰函数的参数**

 表示在函数体内不能修改这个参数的值

###### **（d）修饰函数的返回值**

 （d1）如果给用const修饰返回值的类型为指针，那么函数返回值（即指针）的内容是不能被修改的，而且这个返回值只能赋给被const修饰的指针例如：

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170911844.png)

(d2)如果用const修饰普通的返回值，如返回int变量，由于这个返回值是一个临时变量，在函数调用结束后这个临时变量的生命周期也就结束了，因此把这些返回值修饰为const是没有意义的

##### **typedef和define有什么区别？**

 typedef与define都是替一个对象取一个别名，以此来增强程序的可读性，但是它们在使用和作用上也存在着以下4个方面的不同

###### **（a）原理不同**

 **#define是C语言中定义的语法，它是预处理指令**，在预处理时进行简单而机械的字符串替换，不做正确性检査，不管含义是否正确照样代入，只有在编译已被展开的源程序时，才会发现可能的错误并报错

```
 例如， # define Pl3.1415926 ，当程序执行 area=Pr * r 语句时，PI会被替换为3.1415926于是该 语句被替换为 area=3.1415926*r*r 如果把# define语句中的数字9写成了g，预处理也照样代入，而不去检查其是否合理、合法 
```

typedef是关键字，它在编译时处理，所以 typedef具有类型检查的功能它在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数定义里面使用标识符 typedef例如，typedef int INTEGER ，这以后就可用 INTEGER来代替int作整型变量的类型说明了，例如：INTEGER a,b; 用 typedef定义数组、指针、结构等类型将带来很大的方便，不仅使程序书写简单而且使意义更为明确，因而增强了可读性例如： typedef int a[10]; 表示a是整型数组类型，数组长度为10然后就可用a说明变量，例如:语句a s1,s2；完全等效于语句 int s1[10],s2[10].同理， typedef void（*p）（void)表示p是一种指向void型的指针类型

###### **（b）功能不同**

 typedef用来定义类型的别名，这些类型不仅包含内部类型（int、char等），还包括自定义类型（如 struct），可以起到使类型易于记忆的功能

 例如： typedef int (*PF)(const char *， const char*) 定义一个指向函数的指针的数据类型PF，其中函数返回值为int，参数为 const char*typedef还有另外一个重要的用途，那就是定义机器无关的类型例如，可以定义一个叫REAL的浮点类型，在目标机器上它可以获得最高的精度： typedef long double REAL ，在不支持 long double的机器上，该 typedef 看起来会是下面这样： typedef double real ，在 double都不支持的机器上，该 typedef看起来会是这样： typedef float REAL #define不只是可以为类型取别名，还可以定义常量、变量、编译开关等

###### **（c）作用域不同**

  \#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef有自己的作用域

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170911135.png)

###### **（d）对指针的操作不同** 

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170911187.png) INTPTR1 pl, p2和INTPTR2 p3，p4的效果截然不同 INTPTR1 pl, p2进行字符串替换后变成 int*p1,p2 ，要表达的意义是声明一个指针变量p1和一个整型变量p2

而INTPTR2 p3，p4，由于 INTPTR2是具有含义的，告诉我们是一个指向整型数据的指针，那么p3和p4都为指针变量，这句相当于 int*pl，*p2 .从这里可以看出，进行宏替换是不含任何意义的替换，仅仅为字符串替换；而用 typedef 为一种数据类型起的别名是带有一定含义的。

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170911238.png)

上述代码中， const INTPTR1 p1表示p1是一个常量指针，即不可以通过p1去修改p1指向的内容，但是 p1可以指向其他内容而对于 const INTPTR2 p2，由于 INTPTR2表示的是个指针类型，因此用 const去 限定，表示封锁了这个指针类型，因此p2是一个指针常量，不可使p2再指向其他内容，但可以通过p2修 改其当前指向的内容 INTPTR2 const p3同样声明的是一个指针常量





## **1.2 变量、数组、指针**

### **1.2.1变量**

#### **（a）定义常量谁更好？# define还是 const？**

 尺有所短，寸有所长， define与 const都能定义常量，效果虽然一样，但是各有侧重

 define既可以替代常数值，又可以替代表达式，甚至是代码段，但是容易出错，而 const的引入可以增强程序的可读性，它使程序的维护与调试变得更加方便具体而言，它们的差异主要表现在以下3个方面：

 （a1）define只是用来进行单纯的文本替换，define常量的生命周期止于编译期，不分配内存空间，它存在于程序的代码段，在实际程序中，它只是一个常数；而const常量存在于程序的数据段，并在堆栈中分配了空间，const常量在程序中确确实实存在，并且可以被调用、传递

 （a2）const常量有数据类型，而define常量没有数据类型编译器可以对const常量进行类型安全检査，如类型、语句结构等，而define不行

 （a3）很多IDE支持调试 const定义的常量，而不支持 define定义的常量由于const修饰的变量可以排除 程序之间的不安全性因素，保护程序中的常量不被修改，而且对数据类型也会进行相应的检查，极大地提高了程序的健壮性，所以一般更加倾向于用const来定义常量类型

#### **（b）全局变量和局部变量的区别是什么?**

 （b1）全局变量的作用域为程序块，而局部变量的作用域为当前函数

 （b2）内存存储方式不同，全局变量（静态全局变量，静态局部变量）分配在全局数据区（静态存储空间），后者分配在栈区

 （b3）生命周期不同全局变量随主程序创建而创建，随主程序销毁而销毁，局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在了

 （b4）使用方式不同通过声明为全局变量，程序的各个部分都可以用到，而局部变量只能在局部使用

#### **（c）全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？**

 可以，在不同的C文件中以static形式来声明同名全局变量

 可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错

#### **（d）局部变量能否和全局变量重名？**

 能，局部会屏蔽全局

 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量 对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内

### **1.2.2 数组**与指针

```
简单定义一个数组
int a[10];

简单定义一个指针
int *a=(int *)malloc(sizeof(int)*N);
int *b=&a;
```

```
指针数组，以数组的形式存储指针；
数据类型    *数组名[常量表达式][常量表达式]...... ;
char *arr[]={“Sunday”,“Monday”}
#include <stdio.h>
int main()
{
    //定义三个整型数组
	int a[5] = { 1,2,3,4,5 };
	int b[5] = { 6,4,8,3,1 };
	int c[5] = { 2,5,8,6,1 };
    //定义一个存放指向整型变量的指针的数组arr
    int* arr[] = { a,b,c };//保存的是a b c的首地址
    //通过接引用打印出三个一维数组的元素
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 5; j++)
        {
		    printf("%d ", *(arr[i]+j));
	    }
        printf("\n");
    }
	return 0;
}

1 2 3 4 5

6 4 8 3 1

2 5 8 6 1


#include<stdio.h>
int main()
{
	int i = 0;
	int a[3][4] = { {1,2,3,4} ,{5,6,7,8} ,{9,10,11,12} };//定义一个二维数组
	int* pa[3];//定义一个指针数组
	for (i = 0; i < 3; i++)//给指针数组赋值
		pa[i] = a[i];
    printf("指针数组的内容为:\n");
	for (i = 0; i < 3; i++)//打印出指针数组的内容
	{
		int j;
		for (j = 0; j < 4; j++)
			printf("%d ", *(*(pa + i) + j));
		printf("\n");
	}
    //以下均为不同方式的解引用操作
    printf("不同解引用操作的结果为:\n");
	printf("%d,%d\n", a[1][1], *(pa[1] + 1));
	printf("%d,%d\n", a[1][1], *(*(pa+1) + 1));
	printf("%d,%d\n", a[1][1], (*(pa + 1))[1]);
	printf("%d,%d\n", a[1][1], pa[1][1]);
    return 0;
}
指针数组的内容为:

1 2 3 4
5 6 7 8
9 10 11 12

不同解引用操作的结果为:

6,6
6,6
6,6
6,6


*( pa[i] + j )         //等价于 *( a[i] + j )

*( *(p+i) + j )        //等价于 *( *(a+j) + j )

( *(p+i) )[ j ]        //等价于( *(a+i) )[ j ]

p[ i ][ j ]                //等价于 a[i][j]


对于指针来说 p[x] == *(p+n)
```

```
数组指针 本质上是指针；
int (*p)[4] = a ; 

括号中的*表明 p 是一个指针，它指向一个数组，数组的类型为int [4]，这正是 a 所包含的每个一维数组的类型。

[]的优先级高于*，()是必须要加的，如果赤裸裸地写作int *p[4]，那么应该理解为int *(p[4])，p 就成了一个指针数组，而不是二维数组指针。

有首地址且有长度。
指针数组和二维数组指针的区别
指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：


```

```
int *(p1[5]); //指针数组，可以去掉括号直接写作 int *p1[5]；
int (*p2)[5];//二维数组指针，不能去掉括号
指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。




声明指针时必须声明它所指向对象的类型。计算机需要知道存储对象所需的字节数，所以需要指明类型。以便知道其+1长度。
```



#### **（c）数组下标可以为负数吗？**

 可以，因为下标只是给出了一个与当前地址的偏移量而已，只要根据这个偏移量能定位得到目标地址即可

```
#include <stdio.h>
int main(){
    int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
    int (*p)[4] = a[1];
    printf("%d\n", p[-1][1]);
    return 0;
}
```

**（d）数组名与指针**

```
结论：数组名是一个指针常量，其只能指向数组的首个元素所在地址。当数组作为函数参数时，会转化（有的也称退化）为一个指针，可以进行一些指针的操作，比如a++来读取下一个元素，但是其转化为的指针也还是指向这个数组的。

数组名不作为函数参数时，虽然是一个指针常量，但是不能完全作为一个指针来使用。数组作为函数参数时，就是当做一个指针来使用了。

https://www.cnblogs.com/youxin/p/3235862.html
牛逼文章
```



### **1.2.3 指针**

#### **（a）函数指针**

如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空 间的首地址称为这个函数的地址而且函数名表示的就是这个地址既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913902.png)

这个语句就定义了一个指向函数的指针变量 p首先它是一个指针变量，所以要有一个“*”，即 （*p）； 其次前面的 int 表示这个指针变量可以指向返回值类型为 int 型的函数；后面括号中的两个 int 表示这个 指针变量可以指向有两个参数且都是 int 型的函数所以合起来这个语句的意思就是：定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数p 的类型为 int(*) (int，int)

 我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“（指针变量名）”但是这里需要注意的是：“（指针变量名）”两端的括号不能省略，括号改变了运算符的优先级如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数

 **重要：最后需要注意的是，指向函数的指针变量没有 ++ 和 -- 运算**

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913080.png)

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913214.png)

#### **（b）指针函数**

 首先它是一个函数，只不过这个函数的返回值是一个地址值函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有“函数返回值”，而且，在主调函数中，函数返回值必须赋给同类型的指针变量

类型名 *函数名(函数参数列表)

 其中，后缀运算符括号“()”表示这是一个函数，其前缀运算符星号“*”表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”

 “(函数参数列表)”中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略其示例如下：

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702358060826/D2B5CA33BD970F64A6301FA75AE2EB22)

由于“*”的优先级低于“()”的优先级，因而pfun首先和后面的“()”结合，也就意味着，pfun是一个函数即：

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913567.png)

 接着再和前面的 “*” 结合，说明这个函数的返回值是一个指针由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702358142046/D2B5CA33BD970F64A6301FA75AE2EB22)

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913007.png)

 共有三个学生的成绩，函数find()被定义为指针函数，其形参pointer是指针指向包含4个元素的一维数组 的指针变量pointer+n指向score的第n+1行*(pointer+1)指向第一行的第0个元素pt是一个指针变 量，它指向浮点型变量main()函数中调用find()函数，将score数组的首地址传给pointer

**（c）数组和指针的区别与联系是什么？**

**(c1)存储方式**

 数组通常存储在静态存储区或栈上；指针可以随时随地地指向任意类型的内存块

 数组在内存中是连续存放的，开辟一块连续的内存空间数组是根据数组的下标进行访问的;指针很灵活，它可以指向任意类型的数据指针的类型说明了它所指向地址空间的内存

 **(c2)求sizeof**

 数组：

  数组所占存储空间的内存：sizeof（数组名）

  数组的大小：sizeof（数组名）/sizeof（数据类型）

 指针：

  在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8

 **(c3)数据访问方面**

 指针对数据的访问方式是间接访问，需要用到解引用符号（*数组名）

 数组对数据的访问则是直接访问，可通过下标访问或数组名+元素偏移量的方式

 **(c4)使用环境**

 指针多用于动态数据结构（如链表，等等）和动态内存开辟

 数组多用于存储固定个数且类型统一的数据结构（如线性表等等）和隐式分配

**（d）指针进行强制类型转换后与地址进行加法运算，结果是什么？**

 假设在32位机器上，在对齐为4的情况下,sizeof(long)的结果为4字节，sizeof(char*)的结果为4字节， sizeof(short int)的结果与 sizeof(short)的结果都为2字节， sizeof(char)的结果为1字节， sizeof(int)的结果为4字节，由于32位机器上是4字节对齐，以如下结构体为例：

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702358999461/D2B5CA33BD970F64A6301FA75AE2EB22)

当p=0x100000; 则 p+0×200=? (ulong)p+0x200=? (char*)p+0x200=? 其实,在32位机器下, sizeof(struct BBB)=sizeof(*p)=4+4+2+2+1+3/*补齐*/+2*5+2/*补齐*/=24字节，而 p=0x100000 ,那么 p+0x200=0x1000000+0x200*24 指针加法，加出来的是指针所指类型的字节长度的整倍数，就是p偏移sizeof(p)*0x200。

(ulong)p+0x200=0x10000010+0x200经过ulong后,已经不再是指针加法，而变成一个数值加法了(char*)p+0x200=0x1000000+0×200*sizeof(char) 结果类型是char*

#### **（e）指针常量，常量指针，指向常量的常量指针有什么区别？**

**（e1）指针常量**

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913410.png)



先看const再看 * ，p是一个常量类型的指针，不能修改这个指针的指向，就是指针指向的地址不能修改，但是这个指针所指向的地址上存储的值可以修改

**（e2）常量指针**

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913696.png)

先看*再看const，定义一个指针指向一个常量，不能通过指针来修改这个指针指向的值

**（e3）指向常量的常量指针**

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913326.png)

对于“指向常量的常量指针”，就必须同时满足上述1和2中的内容，既不可以修改指针的值，也不可以修改指针指向的值

#### **（f）指针和引用的异同是什么？如何相互转换？（C++）**

**（f1）相同**

（1）都是地址的概念，指针指向某一内存、内容是所指内存的地址；引用则是某块内存的别名

（2）从内存分配上看：两者都占内存，程序为指针会分配内存，一般是4个字节；而引用的本质是指针常量，指向对象不能变，但指向对象的值可以变两者都是地址概念，所以本身都会占用内存

**（f2）区别**

（1）指针是实体，而引用是别名

（2）指针和引用的自增（++）运算符意义不同，指针是对内存地址自增，引用是对值的自增

（3）引用使用时无需解引用(*)，指针需要解引用；

 （4）引用只能在定义时被初始化一次，之后不可变；指针可变

 （5）引用不能为空，指针可以为空

 （6）“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小，在32 位系统指针变量一般占用4字节内存

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913990.png)

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913039.png)

由结果可知，引用使用时无需解引用(*)，指针需要解引用；我用的是64位操作系统，“sizeof 指针”得到 的是指针本身的大小，及8个字节而“sizeof 引用”得到的是的对象本身的大小及int的大小，4个字节

**（f3）转换**

 （1）指针转引用：把指针用*就可以转换成对象，可以用在引用参数当中

 （2）引用转指针：把引用类型的对象用&取地址就获得指针了

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702359719482/D2B5CA33BD970F64A6301FA75AE2EB22)

#### **（g）野指针是什么？**

（1）野指针是指向不可用内存的指针，当指针被创建，指针不可能自动指向NULL，这时，默认值是随机的，此时的指针成为野指针

（2）当指针被free或delete释放掉时，如果没有把指针设置为NULL，则会产生野指针，因为释放掉的仅仅是指针指向的内存，并没有把指针本身释放掉

 （3）第三个造成野指针的原因是指针操作超越了变量的作用范围

#### **（h）如何避免野指针？**

 （1）对指针进行初始化

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913150.png)

 （2）指针用完后释放内存，将指针赋NULL

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913599.png)

**注：malloc函数分配完内存后需注意：**

 （1） 检查是否分配成功（若分配成功，返回内存的首地址；分配不成功，返回NULL可以通过if语句来判断）

 （2） 清空内存中的数据（malloc分配的空间里可能存在垃圾值，用memset或bzero 函数清空内存）

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913978.png)

#### **（i）C++中的智能指针是什么？**

 智能指针是一个类，用来存储指针（指向动态分配对象的指针）

 C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存

#### **（j）智能指针的内存泄漏如何解决？**

 为了解决循环引用导致的内存泄漏，引入了弱指针 weak_ptr ， weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存， 但是可以检测到所管理的对象是否已经被释放，从而避免非法访问

#### **（k）this指针是什么?**

 **this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参所以对象中不存储this指针**

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402170913715.png)

（1）this指针指向当前对象，可以访问当前对象的所有成员变量包括private、protected、public

 （2）this指针是const指针，一切企图修改该指针的操作，如赋值（改变指向）、增减都是不允许的！

 （3）this指针只有在成员函数中才有定义因此，在创建一个对象后，也不能通过对象使用this指针所以，我们也无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）当然，在成员函数里，你是可以知道this指针的位置的（可以&this获得)，也可以直接使用的

 （4）只有创建对象后，this指针才有意义

 （5）static静态成员函数不能使用this指针原因静态成员函数属于类，而不属于某个对象，所以static静态成员函数压根就没有this指针

 （6）this在成员函数的开始执行前构造的，在成员函数的执行结束后清除至于如何清除的，由编译器实现，程序员不关心this是通过函数参数的首参数来传递的

## **1.3 内存**

### **1.3.1 C语言中内存分配的方式有几种？**

#### （a）静态存储区分配

内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等

#### （b）栈上分配

在函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动释放局部变量、函数内参数都在栈上

#### （c） 堆上分配  

New开辟的空间在堆上

### **1.3.2 堆与栈有什么区别？**

#### **（a）申请方式**

 栈的空间由操作系统自动分配/释放，堆上的空间手动分配/释放

#### **（b）申请大小的限制栈空间有限**

 在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是 一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow因此，能从栈获得的空间较小堆是很大的自由存储区堆是向高地址扩展的数据结构，是不连续的内存区域这是由于系统是用 链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址堆的大小受限于计算机系统中有效的虚拟内存由此可见，堆获得的空间比较灵活，也比较大

#### **（c）申请效率**

 栈由系统自动分配，速度较快但程序员是无法控制的 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.

### **1.3.3 栈在C语言中有什么作用？**

（1）C语言中栈用来存储临时变量，临时变量包括函数参数和函数内部定义的临时变量函数调用中和函数调用相关的函数返回地址，函数中的临时变量，寄存器等均保存在栈中，函数调动返回后从栈中恢复寄存器和临时变量等函数运行场景

（2）多线程编程的基础是栈，栈是多线程编程的基石，每一个线程都最少有一个自己专属的栈，用来存储本线程运行时各个函数的临时变量和维系函数调用和函数返回时的函数调用关系和函数运行场景。操作系统最基本的功能是支持多线程编程，支持中断和异常处理，每个线程都有专属的栈，中断和异常处理也具有专属的栈，栈是操作系统多线程管理的基石

### **1.3.4 C语言函数参数压栈顺序是怎样的？**

先理解入栈和出栈：

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402171018696.png)

栈的范围是由 ss * 10H  至 ss * 10H + sp

（ss）指堆栈寄存器：存放堆栈段起始地址的高16位（即16进制下五个数的前四个数）

（sp）指堆栈指针：用于存放栈顶的逻辑偏移地址

栈的栈底指针不变，栈顶的指针随sp的改变而改变由于栈的栈底地址是高地址，栈顶地址是低地址所以当栈存入数据时，会先将sp减去存入数据的字节数，然后再将数据存入反之，当栈取出数据时，会将数据取出后将sp加上取出数据的字节数（例如,当sp=0800H，ss=2360H时,若此时加入20个字节的数据，那么就要将sp-20,此时的栈顶就是ss * 10H + sp）

注：所谓高地址与低地址，前面的地址称为低地址，后面的地址称为高地址，例如23600H与23E00H,此时23600H为低地址，23E00H为高地址

**回答这个问题：**从右至左

C语言参数入栈顺序的好处就是可以动态变化参数个数自左向右的入栈方式，最前面的参数被压在栈底除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数这样就变成了左边参数的个数不确定，正好和动态参数个数的方向相反因此，Ｃ语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式

例如： printf（const char* format,…）

（1）printf函数是一个不定参函数

（2）编译器通过format的%占位符的个数来获取参数的个数

（3）假设函数压栈顺序是从左至右，format先入栈，各个参数再入栈，最后pc入栈入栈完之后，想知道参数的个数就要读取format，但要读取format就得知道参数的个数，陷入了一个死循环

（4）但是，如果函数压栈顺序是从右至左，未知个数的参数先入栈，format再入栈，最后压pc入栈这时候要想知道参数的个数只需要将栈顶指针加2即可读取到format

### **1.3.5 C++的内存管理是怎样的？**

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分

 **代码段：**包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码

 **数据段**：存储程序中已初始化的全局变量和静态变量

 **BSS段：**存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量

 **堆区：**调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存

 **映射区:**存储动态链接库以及调用mmap函数进行的文件映射

 **栈：**使用栈空间存储函数的返回地址、参数、局部变量、返回值

### **1.3.6 什么是内存泄漏？**

 简单地说就是申请了一块内存空间，使用完毕后没有释放掉

 它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄露了

### **1.3.7 如何判断内存泄漏？**

（1）良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄露当程式稳定之后，在来检测内存泄露时，无疑增加了排除的困难和复杂度使用了内存分配的函数，一旦使用完毕,要记得要使用其相应的函数释放掉

（2）将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表

（3）Boost 中的smart pointer

（4）一些常见的工具插件，如ccmalloc、Dmalloc、Leaky等等

### **1.3.8 new/delete与malloc/free的区别是什么？**

在C++中，申请动态内存和释放动态内存，用new/delete 和 malloc/free都可以，new和malloc动态申请的内存都位于堆中，无法被操作系统回收，需要对应的delete/free来释放空间

void *malloc(int size);

说明：malloc向系统申请分配指定size个字节的内存空间返回类型是 void* 类型void* 表示未确定类型的指针C,C++规定，void* 类型可以强制转换为任何其它类型的指针

对于类的对象而言，malloc/free无法满足动态对象的要求，对象在创建时要自动执行构造函数，在对象消亡之前要自动执行析构函数，而malloc/free 不在编译器控制权限之内，无法执行构造函数和析构函数

当然对于没有资源要清理的类，不调用析构函数也没有太大的问题，即使用free或delete没有区别但万一有一些类的成员是指针，而这个指针又在堆上开辟了空间，这时不调用析构函数去释放这个指针指向的这段空间，就会造成内存泄漏delete会调用析构函数，释放指针成员变量的空间，再销毁对象本身的空间；而free只释放了对象本身的空间，而指针成员所指向的空间没有被释放

（1）new 能够自动计算需要分配的内存空间，而malloc需要手工计算字节数

（2) new与delete带具体类型的指针，malloc与free返回void类型的指针

（3）new 将调用构造函数，而malloc不能；delete将调用析构函数，而free不能

（4）malloc/free 需要库文件<stdlib.h>支持，而new/delete不需要库文件支持

（5）new操作可以重载，可以自定义内存分配策略，不做内存分配，或者分配到非内存设备上而malloc不能

delete和free被调用后，内存不会不会立即收回，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放啦，还可以做其他用途由于没有对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况，因此，释放完内存后需要将指针向量置为空



## **1.4 预处理**

### **1.4.1 预处理器标识#error的目的是什么？**

\#error预处理指令的作用是，编译程序时，只要遇到#error就会生成一个编译错误提示消息，并停止编译其语法格式为：#error error-message

下面举个例子： 程序中往往有很多的预处理指令

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702360939401/D2B5CA33BD970F64A6301FA75AE2EB22)

当程序比较大时，往往有些宏定义是在外部指定的（如makefile），或是在系统头文件中指定的，当你 不太确定当前是否定义了 XXX 时，就可以改成如下这样进行编译：

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402171025595.png)

这样,如果编译时出现错误,输出了XXX has been defined,表明宏XXX已经被定义了

### **1.4.2 如何使用 define声明个常数，用以表明1年中有多少秒（忽略闰年问题）**

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402171025870.png)

考虑到可能存在数据溢出问题，更加规范化的写法是使用长整型类型，即UL类型，告诉编译器这个常数是长整型数

### **1.4.3 # include< filename. h>和#include" filename. h"有什么区别？**

对于 include< filename. h>，编译器先从标准库路径开始搜索filename.h，使得系统文件调用较快而 对于# include“ filename.h”，编译器先从用户的工作路径开始搜索filename.h，然后去寻找系统路径，使得自定义文件较快

### **1.4.4 头文件的作用有哪些？**

头文件的作用主要表现为以下两个方面：

（1）通过头文件来调用库功能出于对源代码保密的考虑，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口是怎么实现的编译器会从库中提取相应的代码

（2）头文件能加强类型安全检查当某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，大大减轻程序员调试、改错的负担

### **1.4.5 在头文件中定义静态变量是否可行，为什么?**

不可行，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误因为如果在使用了该头文件的每个C语言文件中定义静态变量，按照编译的步骤，在每个头文件中都会单独存在一个静态变量，从而会引起空间浪费或者程序错误所以，不推荐在头文件中定义任何变量，当然也包括静态变量

### **1.4.6 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个**

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702361125204/D2B5CA33BD970F64A6301FA75AE2EB22)

## **1.5 其他C语言面试问题**

### **1.5.1 C语言宏中“#”和“##”的用法**

#### **（a）“#”字符串化操作符**

作用：#可以把一个宏参数直接转换成相应的字符串比如有下面这个宏：

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702361917241/D2B5CA33BD970F64A6301FA75AE2EB22)

则进行如下调用：

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402171026024.png)

最后其执行效果如下面程序一样：

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702361961974/D2B5CA33BD970F64A6301FA75AE2EB22)

也就是说，最后输出的是宏参数的参数名即：将宏参数直接转换成相应得字符串

#### **（b）“##”符号连接操作符**

作用：将宏定义的多个形参转换成一个实际参数名

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402171026091.png)

则下面第一个图的代码和第二个图的代码等价：

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702362011661/D2B5CA33BD970F64A6301FA75AE2EB22)

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702362028068/D2B5CA33BD970F64A6301FA75AE2EB22)

### **1.5.2 extern”C” 的作用是什么？**

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702362065710/D2B5CA33BD970F64A6301FA75AE2EB22)

### **1.5.3 strlen("\0") =？ sizeof("\0")=? 两者结果与区别**

strlen("\0") =0，sizeof("\0")=2

strlen用来计算字符串的长度（在C/C++中，字符串是以"\0"作为结束符的），它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描直到碰到第一个字符串结束符\0为止，然后返回计数器值sizeof是C语言的关键字，它以字节的形式给出了其操作数的存储大小，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定

attribute 可以指定编译时的细节。其可作用于变量、函数、结构体、结构体成员。
值的注意的是，Attributes 机制并不是 C标准 的一部分。因此，使用 Attributes 的程序有时候不可跨编译器移植。但是，目前市面上多数的 C/C++ IDE使用的编译工具链都是 GCC，包括很多的商业 IDE 的编译工具链也是基于 GCC 优化过的版本。因此 GNU C的__attribute__ 一般是可以兼容的，在 uboot 和 Linux 源码中会常用到此__attribute__机制。



### **1.5.4 C语言中 struct与 union的区别是什么?**

struct（结构体）与 union（联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，区别主要表现在以下两个方面：

（1）结构体与联合体虽然都是由多个不同的数据类型成员组成的，但不同之处在于联合体中所有成员共用一块地址空间，即联合体只存放了一个被选中的成员，而结构体中所有成员占用空间是累加的， 其所有成员都存在，不同成员会存放在不同的地址在计算一个结构型变量的总长度时，其内存空间大小等于所有成员长度之和（需要考虑字节对齐），而在联合体中，所有成员不能同时占用内存空间，它们不能同时存在，所以一个联合型变量的长度等于其最长的成员的长度

（2）对于联合体的不同成员赋值，将会对它的其他成员重写，原来成员的值就不存在了，而对结构体的不同成员赋值是互不影响的

![img](https://cdn.jsdelivr.net/gh/mrqiujb/picture_home/typora_pic/202402171026743.png)

假设为32位机器，int型占4个字节， double型占8个字节，char型占1个字节，而DATE是一个联合型变 量，联合型变量共用空间，uion里面最大的变量类型是int[5]，所以占用20个字节，它的大小是20，而 由于 union中，double占了8个字节，因此 union是要8个字节对齐，所占内存空间为8的倍数为了实现 8个字节对齐，所占空间为24.而data是一个结构体变量，每个变量分开占用空间，依次为

sizeof（int） + sizeof（DATE）+ sizeof（ double）=4+24+8=36按照8字节对齐，占用空间为40，所以结果为 40+24=64

### **1.5.5 左值和右值是什么？**

左值是指可以出现在等号左边的变量或表达式，它最重要的特点就是可写（可寻址）也就是说，它的值可以被修改，如果一个变量或表达式的值不能被修改，那么它就不能作为左值

右值是指只可以出现在等号右边的变量或表达式它最重要的特点是可读一般的使用场景都是把一个右值赋值给一个左值通常，左值可以作为右值，但是右值不一定是左值

### **1.5.6 有符号数和无符号数的运算？**  

int a = -20， unsigned int b = 6，a+b是否大于6？

 有符号和无符号运算，强制转换为无符号，所有a+b会变成（unsigned int）a+b；

 (unsigned int)a 就会相当于无符号最大值-20，那么是一个非常大的值，这个值加上6，那么肯定是大于6的；

 最后的值是2^32-20+6=4294967282,肯定大于6

### **1.5.7 什么是短路求值？**

![img](https://uploadfiles.nowcoder.com/images/20231212/732217308_1702362224730/D2B5CA33BD970F64A6301FA75AE2EB22)

输出结果为1输出为什么不是2，而是1呢？

 其实，这里就涉及一个短路计算的问题由于i语句是个条件判断语句，里 面是有两个简单语句进行或运算组合的复合语句，因为或运算中，只要参与或运算的两个表达式的值都为真，则整个运算结果为真，而由于变量i的值为6，已经大于0了，而该语句已经为true，则不需要执行后续的j+操作来判断真假，所以后续的j++操作不需要执行，j的值仍然为1

 因为短路计算的问题，对于&&操作，由于在两个表达式的返回值中，如果有一个为假则整个表达式的值 都为假，如果前一个语句的返回值为 false，则无论后一个语句的返回值是真是假，整个条件判断都为 假，不用执行后一个语句，而a>b的返回值为 false，程序不执行表达式n=c>d，所以，n的值保持为初值2

### **1.5.8 什么是大端和小端？**

 大端：高地址存低字节，低地址存高字节

 小端：低地址存低字节，高地址存高字节

### **1.5.9 ++a和a++有什么区别？两者是如何实现的？**

 a++的具体运算过程为： 先用a，再执行++

++a的具体运算过程为：  先执行++，再用a





# gcc

### gcc优化

编译器优化介绍：
由于内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件级别的优化。再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器进行优化。编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier)Linux 提供了一个宏解决编译器的执行顺序问题。
void Barrier(void)
这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。

2、volatile总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以消除一些代码。但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化。

volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）。

通常C语言的编译器使用的是GCC编译器，他有个以下几个等级的优化

- -O0 ：(默认)：没有优化。
- -O或-O1 ：优化，但不要花费太多的时间。
- -O2 ：更积极地优化
- -O3 ：最积极地优化
- -Ofast ：最高级的优化
- -Os ： 优化代码大小
- -Og ：在尽量不干扰调试的情况下优化